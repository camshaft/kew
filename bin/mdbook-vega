#!/usr/bin/env node

import { stdin, argv } from "node:process";
import { basename, dirname, join } from "node:path";
import { readFile, writeFile } from "node:fs/promises";
import vega from "vega";
import vegaLite from "vega-lite";

const assert = (cond) => {
  if (!cond) process.exit(1);
};

if (process.argv.length > 2) {
  const [_env, _bin, supports, _renderer] = argv;
  assert(supports == "supports", supports);
  process.exit(0);
}

async function input() {
  return new Promise((resolve, reject) => {
    const chunks = [];

    stdin.resume();
    stdin.setEncoding("utf8");

    stdin.on("data", (chunk) => {
      chunks.push(chunk);
    });

    stdin.on("error", reject);

    stdin.on("end", () => {
      resolve(JSON.parse(chunks.join()));
    });
  });
}

async function replaceAsync(str, regex, asyncFn) {
  const promises = [];
  str.replace(regex, (full, ...args) => {
    promises.push(asyncFn(full, ...args));
    return full;
  });
  const data = await Promise.all(promises);
  return str.replace(regex, () => data.shift());
}

const [config, book] = await input();

function compile(json) {
  return json["$schema"].includes("lite") ? vegaLite.compile(json).spec : json;
}

async function renderToSvg(json, dir) {
  const logger = {
    level() {
      console.error("LEVEL", ...arguments);
    },
    error() {
      console.error("ERROR", ...arguments);
    },
    warn() {
      console.error("WARN", ...arguments);
    },
    info() {
      //console.error('INFO', ...arguments);
    },
    debug() {
      //console.error('DEBUG', ...arguments);
    },
  };

  const parsed = vega.parse(json);

  const loader = {
    sanitize() { },
    load: async function load(file) {
      const resolved = join(dir, file);
      return await readFile(resolved);
    },
    fileAccess: true,
    file: async function file() {
      throw new Error();
    },
    http: async function http() {
      throw new Error();
    },
  };

  const view = new vega.View(parsed, {
    renderer: "svg",
    logLevel: vega.DEBUG,
    loader,
    logger,
  });

  return await view.toSVG();
}

async function renderPath(path) {
  const dir = dirname(path);
  const contents = await readFile(path);
  const compiled = compile(JSON.parse(contents));
  const svg = await renderToSvg(compiled, dir);

  const svgPath = path.replace(/\.json$/, ".svg");
  await writeFile(svgPath, svg);

  const url = basename(svgPath);

  if (config.renderer != "html") return `![](${url})`;

  const compiledPath = path.replace(/\.json$/, ".min.json");

  let site_url = config.config.output.html["site-url"] || "/";
  if (!site_url.match(/\/$/)) site_url += "/";
  const resolve = (url) => (url.charAt(0) == "/" ? url : `${site_url}${url}`);

  compiled.data.forEach((data) => {
    if (data.url) data.url = resolve(data.url);
  });

  await writeFile(compiledPath, JSON.stringify(compiled));

  const jsonUrl = resolve(basename(compiledPath));
  return `<img data-vega="${jsonUrl}" src="${resolve(url)}"/>`;
}

async function renderSection(section) {
  const { Chapter } = section;

  if (Chapter) {
    Chapter.content = await replaceAsync(
      Chapter.content || "",
      /\#VEGA\(([^\)]+)\)/g,
      async (_match, path) => {
        return await renderPath(path);
      }
    );

    const sub_items = Chapter.sub_items || [];
    for (let item of sub_items) {
      await renderSection(item);
    }
  }
}

for (let section of book.sections) {
  await renderSection(section);
}

console.log(JSON.stringify(book));
